#!/usr/bin/env python
# coding: utf-8

import sys
import time

from twisted.internet import defer
from twisted.internet import protocol
from twisted.internet import reactor
from twisted.python import log
import socket

sys.path.append(".")

import marionette_tg
import marionette_tg.conf


if len(sys.argv)<3:
    print 'usage: marionette_server [proxy_ip] [proxy_port] [format]'
    sys.exit(1)
REMOTE_IP = str(sys.argv[1])
REMOTE_PORT = int(sys.argv[2])
if len(sys.argv) >= 4:
    FORMAT = str(sys.argv[3])
else:
    FORMAT = 'http_simple_blocking'

MAX_TO_SEND = 2**18

class ProxyServerProtocol(protocol.Protocol):

    def connectionMade(self):
        log.msg("ProxyServerProtocol: connected to peer")
        self.cli_queue = self.factory.cli_queue
        self.cli_queue.get().addCallback(self.serverDataReceived)

    def serverDataReceived(self, chunk):
        if chunk is False:
            self.cli_queue = None
            log.msg("ProxyServerProtocol: disconnecting from peer")
            self.factory.continueTrying = False
            self.transport.loseConnection()
        elif self.cli_queue:
            log.msg(
                "ProxyServerProtocol: writing %d bytes to peer" %
                len(chunk))

            to_send = chunk
            handle = self.transport.getHandle()
            while len(to_send)>0:
                try:
                    bytes_sent = handle.send(to_send)
                    to_send = to_send[bytes_sent:]
                except socket.error as e:
                    if str(e) == '[Errno 35] Resource temporarily unavailable':
                        time.sleep(0) # yield to allow Python to process outgoing messages
                        continue
                    else:
                        break

            self.cli_queue.get().addCallback(self.serverDataReceived)
        else:
            log.msg(
                "ProxyServerProtocol: (2) writing %d bytes to peer" %
                len(chunk))
            self.factory.cli_queue.put(chunk)

    def dataReceived(self, chunk):
        log.msg(
            "ProxyServerProtocol: %d bytes received from peer" %
            len(chunk))
        self.factory.srv_queue.put(chunk)

    def connectionLost(self, why):
        log.msg("ProxyServerProtocol.connectionLost: " + str(why))
        if self.cli_queue:
            self.cli_queue = None
            log.msg("ProxyServerProtocol: peer disconnected unexpectedly")


class ProxyServerFactory(protocol.ClientFactory):
    protocol = ProxyServerProtocol

    def __init__(self, srv_queue, cli_queue):
        self.srv_queue = srv_queue
        self.cli_queue = cli_queue


class ProxyServer(object):

    def __init__(self):
        self.connector = None

    def connectionMade(self, marionette_stream):
        log.msg("ProxyServer.connectionMade")
        self.cli_queue = defer.DeferredQueue()
        self.srv_queue = defer.DeferredQueue()
        self.marionette_stream = marionette_stream
        self.srv_queue.get().addCallback(self.clientDataReceived)

        self.factory = ProxyServerFactory(self.srv_queue, self.cli_queue)
        self.connector = reactor.connectTCP(
            REMOTE_IP,
            REMOTE_PORT,
            self.factory)

    def clientDataReceived(self, chunk):
        log.msg(
            "ProxyServer.clientDataReceived: writing %d bytes to original client" %
            len(chunk))
        self.marionette_stream.push(chunk)
        self.srv_queue.get().addCallback(self.clientDataReceived)

    def dataReceived(self, chunk):
        log.msg("ProxyServer.dataReceived: %s bytes" % len(chunk))
        self.cli_queue.put(chunk)

    def connectionLost(self):
        log.msg("ProxyServer.connectionLost")
        self.cli_queue.put(False)
        self.connector.disconnect()


if __name__ == "__main__":
    if marionette_tg.conf.get("general.debug"):
        log.startLogging(sys.stdout)

    server = marionette_tg.Server(FORMAT)
    server.factory = ProxyServer

    reactor.callFromThread(server.execute, reactor)

    reactor.run()
